### 其他知识  
1.自动装箱与拆箱  
装箱:将基本类型用它们对应的引用类型包装起来  
拆箱:将包装类型转换为基本类型  

2.在静态方法内调用一个非静态成员为什么是非法的  
由于静态方法可以不通过对象进行调用,因此在静态方法里不能调用非静态变量,也不可以访问非静态变量成员  

3.在java中定义一个不做事且没有参数的构造方法的作用  
解决在没有使用super()调用父类特定方法时编译报错的问题  
java程序在执行子类构造方法一般会使用super()调用特定方法,不使用时则可以调用定义的不做事且没有参数的构造方法  

4.接口和抽象类的区别  
* 接口的默认方法是public,所有方法在接口中不能有实现,而抽象类可以有非抽象方法  
* 接口中只能有static,final变量,不能有其他变量  
* 一个类中只能实现一个抽象类,但接口可以实现多个通过extends关键字扩展  
* 从设计层面上说:抽象是对类的抽象,是一种模板设计;接口是对行为的抽象,是一种行为的规范  

5.线程,程序,进程的概念及关系
* 程序:  
程序是含有指令和数据的文件,被存储在磁盘或其他存储设备中,程序是静态的代码   
* 线程:  
线程与进程相似,但线程是比进程更小的执行单位,一个进程在执行的过程中可以产生多个线程.  
线程又被称为轻量级进程:  
多个线程共享同一块内存空间和一组系统资源,所以系统在产生一个线程,或在各个线程之间切换时负担比进程小  
  * 线程的基本状态:  
  在线程的生命周期的指定时刻只可能处于六种状态  
  1.`new` 初始状态  
  2.`runnable` 运行状态  
  3.`blocked` 阻塞状态  
  4.`waiting` 等待状态  
  5.`time_waiting` 超时等待状态,指定时间自行返回  
  6.`terminated` 终止状态  
  * 线程状态变迁过程  
  1.`线程创建后处于new`(新建)状态,  
  2.`调用start`()方法后开始运行,`此时线程出入ready`(可运行)状态.  
  3.可运行状态的线程获得了cpu时间片(timeslice)后处于`running`(运行)状态.  
  4.当线程执行wait()方法之后,线程进入`**waiting`(等待),`**`状态.  
  5.进入等待状态的线程需要依靠其他线程的通知才能够返回得运行状态,  
  6.`time_waiting`(超时等待)状态相当于在等待状态的基础上增加了超时限制,比如通过`sleep`(long millis)方法或`wait`(long millis)方法可以将java线程置于`timed waiting`状态.  
  7.当超时时间到达后java线程将会返回到`runnable`状态.  
  8.当线程调用同步方法时,在没有获取到锁的情况下,线程会进入到`blicked`(阻塞)状态.  
  9.线程在执行`runnable`的`run`()方法之后将会进入到`terminated`(终止)状态.
* 进程:  
进程是程序的一次执行过程,是系统运行程序的基本单位.因此进程进程是动态的,系统运行程序是从一个进程创建,运行到消亡的过程  
一个进程就是一个执行中的程序.  
线程是进程划分成更小的运行单位.线程和进程最大的不同在于基本上各进程是独立的,而各线程则不一定  
进程属于操作系统的范畴,同一段时间内,可以同时执行一个以上的程序,而线程在同一个程序内几乎同时执行一个以上的程序段.  
